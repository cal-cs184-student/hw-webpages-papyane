 <html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Elen Papyan </div>

		<br>

		Link to webpage:  <a href="https://cal-cs184-student.github.io/hw-webpages-papyane/">papyane</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		
			In this homework, we created a very barebones renderer. We have given the user the ability to render both colored and textured images by working from the bottom up--points, lines, and triangles. In order for images to appear smoothly, we implement antialiasing techniques for the user to utilize as they wish.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		To rasterize triangles, the simplest and most effective method is to sample pixels in the bounding box, so the smallest box that contains the triangle. The process of sampling the pixels is as such. We find the change in x and the change in y between each pair of points. This will help us when we construct the line equations 
			for each pair of vertices. The line equation is just the pixel point we are sampling dot product with the normal vector of the line between the two points (the normal is perpendicular to the tangent, so we flip the coordinates and add a negative to the first coordinate). Now checking whether or not a pixel is in the triangle 
			checks whether or not the three line equations are ALL greater than (or equal to) 0, or ALL less than (or equal to) 0. Checking both all greater and all less than accounts for the order that the triangles are passed in (counterclockwise or clockwise).
		
		My algorithm is exactly the one that checks each sample without the bounding box of the triangle.  
		<p>Below is an image of rasterized triangles</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part_1_interesting.png" width="400px"/>
				  <figcaption>Triangles!</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		My algorithm uses the approach where we use sample buffer as a higher resolution grid based on the sample rate (width * height * sample rate). At the level of rasterizing the triangle, instead of immediately 
			calling rasterize point, we put valid pixels (subsampled based on the sqrt of the sample rate) into a sample buffer that is the larger size above necessary to account for the subsampling occurring at every 
			pixel. Then downsample in order to fill the target framebuffer by taking our “high resolution” sample buffer and averaging the subpixels of every pixel. To make sure that sample buffer changes dynamically, 
			within set_sample_rate and set_framebuffer_target we make sure that the sample buffer is of the correct size, thus making it so that when the window is resized or the sampling rate is changed the code will 
			dynamically update the space of the sample buffer. We also changed the fill pixel to add every subsampled point within the pixel into the sample buffer. Super sampling is useful because then we can create a 
			low pass filter which removes the high frequency jagginess of objects. This effect close up will lead to a smoother look when zoomed out.  
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part2_1.png" width="400px"/>
				  <figcaption> sample rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part2_4.png" width="400px"/>
				  <figcaption> sample rate 4</figcaption>
				</td>
			  </tr>
				</tr>
				<td style="text-align: center;">
				  <img src="part2_9.png" width="400px"/>
				  <figcaption> sample rate 9</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part2_16.png" width="400px"/>
				  <figcaption> sample rate 16</figcaption>
				</td>
				</tr>
			</table>
		</div>
			
		<h2>Task 3: Transforms</h2>
		With my cubeman, I wanted to make him do the splits!! So for the left leg, I added a rotation of 90 degrees counterclockwise and for the right leg, 
			I added a rotation of -90 degrees counterclockwise. These were after the first transform that was in the file already, but before any specific 
			transforms to the parts of the leg.    
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part3.png" width="400px"/>
				  <figcaption>cubeman!</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates represent a weighted average of given vertices. In our case, we have three vertices and when we represent a triangle with barycentric coordinates, we give a value to each pixel within the triangle that is based on a weighted average of the vertices. 
			If each vertex represents a color, then the resulting pixel will have a color that is based on this weighted average of the vertex colors. As we can see in the triangle below with red, blue, green vertices, the pixels in the middle of the triangle end up with a gray-ish color 
			that is representative of an even mix of red blue and green. If we move towards the green vertex, we can see the influence of red and blue decrease
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part4_triangle.png" width="400px"/>
				  <figcaption> colored triangle</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part4_wheel.png" width="400px"/>
				  <figcaption>color wheel</figcaption>
				</td>
			</table>
		</div>
			
		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling takes a continuous coordinate on the screen and translates it to a value from some discrete source, which were our texture maps in this case. To begin, similarly to Task 4, we used barycentric coordinates to find the value of the interpolated texture coordinate (u,v). These coordinates are then passed into the correct type of sampling method, either nearest or bilinear, which then return the color we want at that point. Nearest neighbor quite literally snaps the given (u,v) coordinates (after scaling for the texture height and width) to the nearest texel. This may result in jagginess since multiple pixels will map to the same texel. Bilinear interpolation considers the four nearest texels that surround (u,v). We do three linear interpolations based on the distance between the point and the texel centers around it. This will give us a smoother, more blurred result.

		<p> As we can see below, nearest with 1 super sampling is the most blocky and jagged, and while 16 pixel supersampling helps the edges of the letter A be smoother, the overall texture of the A is still jaggy. Immediately, we see that using bilinear with 1 supersampling resolves this and the morphed A does not look blocky or zig-zagy, instead it looks like it’s been smoothly manipulated. Bilinear with 16 supersampling is very similar to 1 sampling, but it just cleans up some parts of the A. 
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part5_nearest_1.png" width="400px"/>
				  <figcaption> nearest with 1 sample rate</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part5_nearest_16.png" width="400px"/>
				  <figcaption> nearest with 16 sample rate</figcaption>
				</td>
			  </tr>
				</tr>
				<td style="text-align: center;">
				  <img src="part5_bilinear_1.png" width="400px"/>
				  <figcaption> bilinear with 1 sample rate</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part5_bilinear_16.png" width="400px"/>
				  <figcaption> bilinear with 16 sample rate</figcaption>
				</td>
				</tr>
			</table>
		</div>
		
		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>
