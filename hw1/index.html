 <html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Elen Papyan </div>

		<br>

		Link to webpage:  <a href="https://cal-cs184-student.github.io/hw-webpages-papyane/">papyane</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		
			In this homework, we created a very barebones renderer. We have given the user the ability to render both colored and textured images by working from the bottom up--points, lines, and triangles. In order for images to appear smoothly, we implement antialiasing techniques for the user to utilize as they wish.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		To rasterize triangles, the simplest and most effective method is to sample pixels in the bounding box, so the smallest box that contains the triangle. The process of sampling the pixels is as such. We find the change in x and the change in y between each pair of points. This will help us when we construct the line equations 
			for each pair of vertices. The line equation is just the pixel point we are sampling dot product with the normal vector of the line between the two points (the normal is perpendicular to the tangent, so we flip the coordinates and add a negative to the first coordinate). Now checking whether or not a pixel is in the triangle 
			checks whether or not the three line equations are ALL greater than (or equal to) 0, or ALL less than (or equal to) 0. Checking both all greater and all less than accounts for the order that the triangles are passed in (counterclockwise or clockwise).
		
		My algorithm is exactly the one that checks each sample without the bounding box of the triangle.  
		<p>Below is an image of rasterized triangles</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part_1_interesting.png" width="400px"/>
				  <figcaption>Triangles!</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		My algorithm uses the approach where we use sample buffer as a higher resolution grid based on the sample rate (width * height * sample rate). At the level of rasterizing the triangle, instead of immediately 
			calling rasterize point, we put valid pixels (subsampled based on the sqrt of the sample rate) into a sample buffer that is the larger size above necessary to account for the subsampling occurring at every 
			pixel. Then downsample in order to fill the target framebuffer by taking our “high resolution” sample buffer and averaging the subpixels of every pixel. To make sure that sample buffer changes dynamically, 
			within set_sample_rate and set_framebuffer_target we make sure that the sample buffer is of the correct size, thus making it so that when the window is resized or the sampling rate is changed the code will 
			dynamically update the space of the sample buffer. We also changed the fill pixel to add every subsampled point within the pixel into the sample buffer. Super sampling is useful because then we can create a 
			low pass filter which removes the high frequency jagginess of objects. This effect close up will lead to a smoother look when zoomed out.  
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part2_1.png" width="400px"/>
				  <figcaption> sample rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part2_4.png" width="400px"/>
				  <figcaption> sample rate 4</figcaption>
				</td>
			  </tr>
				</tr>
				<td style="text-align: center;">
				  <img src="part2_9.png" width="400px"/>
				  <figcaption> sample rate 9</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part2_16.png" width="400px"/>
				  <figcaption> sample rate 16</figcaption>
				</td>
				</tr>
			</table>
		</div>
			
		<h2>Task 3: Transforms</h2>
		With my cubeman, I wanted to make him do the splits!! So for the left leg, I added a rotation of 90 degrees counterclockwise and for the right leg, 
			I added a rotation of -90 degrees counterclockwise. These were after the first transform that was in the file already, but before any specific 
			transforms to the parts of the leg.    
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part3.png" width="400px"/>
				  <figcaption>cubeman!</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates represent a weighted average of given vertices. In our case, we have three vertices and when we represent a triangle with barycentric coordinates, we give a value to each pixel within the triangle that is based on a weighted average of the vertices. 
			If each vertex represents a color, then the resulting pixel will have a color that is based on this weighted average of the vertex colors. As we can see in the triangle below with red, blue, green vertices, the pixels in the middle of the triangle end up with a gray-ish color 
			that is representative of an even mix of red blue and green. If we move towards the green vertex, we can see the influence of red and blue decrease
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part4_triangle.png" width="400px"/>
				  <figcaption> colored triangle</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part4_wheel.png" width="400px"/>
				  <figcaption>color wheel</figcaption>
				</td>
			</table>
		</div>
			
		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling takes a continuous coordinate on the screen and translates it to a value from some discrete source, which were our texture maps in this case. To begin, similarly to Task 4, we used barycentric coordinates to find the value of the interpolated texture coordinate (u,v). These coordinates are then passed into the correct type of sampling method, either nearest or bilinear, which then return the color we want at that point. Nearest neighbor quite literally snaps the given (u,v) coordinates (after scaling for the texture height and width) to the nearest texel. This may result in jagginess since multiple pixels will map to the same texel. Bilinear interpolation considers the four nearest texels that surround (u,v). We do three linear interpolations based on the distance between the point and the texel centers around it. This will give us a smoother, more blurred result.

		<p> As we can see below, nearest with 1 super sampling is the most blocky and jagged, and while 16 pixel supersampling helps the edges of the letter A be smoother, the overall texture of the A is still jaggy. Immediately, we see that using bilinear with 1 supersampling resolves this and the morphed A does not look blocky or zig-zagy, instead it looks like it’s been smoothly manipulated. Bilinear with 16 supersampling is very similar to 1 sampling, but it just cleans up some parts of the A. 
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part5_nearest_1.png" width="400px"/>
				  <figcaption> nearest with 1 sample rate</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part5_nearest_16.png" width="400px"/>
				  <figcaption> nearest with 16 sample rate</figcaption>
				</td>
			  </tr>
				</tr>
				<td style="text-align: center;">
				  <img src="part5_bilinear_1.png" width="400px"/>
				  <figcaption> bilinear with 1 sample rate</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part5_bilinear_16.png" width="400px"/>
				  <figcaption> bilinear with 16 sample rate</figcaption>
				</td>
				</tr>
			</table>
		</div>
		
		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Explain level sampling in your own words and describe how you implemented it for texture mapping.
		Level sampling, or mipmapping, is essentially a solution to the minification problem. When we have an object that is far away and if we sample one texel per pixel, we would skip over a lot of texture data which would cause the Moiré pattern and other jagginess. Through level sampling we can pre-compute blurred, lower resolution versions of the texture. We match the size of the texture to the distance of the object, so how much of the texture a single screen pixel covers. 
		To implement this, we need to find the barycentric coordinates for points around (x,y), so (x+1, y) and (x, y+1), in order to see how fast the (u,v) coordinates change across one screen pixel, in both the x and y directions. Once we have those derivatives, to get the level of a pixel, we took the dx or dy vector which had the maximum length and ran it through log base 2. Then in the sample function, depending on the type of level sampling that is chosen by the user, we use the level value that we found in different ways. For L_ZERO, the level must be zero. For L_NEAREST, we found the level to the nearest integer. For L_LINEAR, we take the floor and ceiling of the level and linearly interpolate from the two adjacent levels. 

		<p> In terms of speed, supersampling is the slowest of all three since it scales linearly depending on the size of the sample rate. The fastest method is definitely pixel sampling at the nearest level since it just requires 1 texel lookup, while bilinear requires four lookups as well as linear interpolation. Level sampling also gets slower when we consider nearest and linear, since they require derivatives and more linear interpolation. Memory usage is most effective when using pixel sampling since we do not need to story anything more than the base texture. Mipmapping requires 1/3rd more memory, but the worst is supersampling because it once again scales with the sample rate. Each technique has it’s own strengths. Despite the speed and memory usage because worse when considering supersampling, it is the best at fixing geometric aliasing like jagged edges. Mipmapping is best when we minimize an image and we want to retain quality without things like Moiré patterns. Pixel sampling is best with magnification as it will smooth blocky pixels into looking like gradients.</p>	
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part6_level0_linear.png" width="400px"/>
				  <figcaption> checkerboard with level 0 mipmap and bilinear pixel sampling</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part6_level0_nearest.png" width="400px"/>
				  <figcaption> checkerboard with level 0 mipmap and nearest pixel sampling</figcaption>
				</td>
			  </tr>
				</tr>
				<td style="text-align: center;">
				  <img src="part6_levelnear_linear.png" width="400px"/>
				  <figcaption> checkerboard with nearest mipmap and bilinear pixel sampling</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part6_levelnear_nearest.png" width="400px"/>
				  <figcaption> checkerboard with nearest mipmap and nearest pixel sampling</figcaption>
				</td>
				</tr>
			</table>
		</div>
		</div>
	</body>
</html>
